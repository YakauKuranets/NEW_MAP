# Руководство по проекту «Map v12»

## Общий обзор проекта

Проект «Map v12» — это веб‑приложение для отображения объектов на карте с возможностью добавления, редактирования и фильтрации точек.  
Ключевые функции приложения:

* **Интерактивная карта** с маркерами, построенная на Leaflet. Пользователь видит список всех объектов (адресов) и может фильтровать их по категории и типу доступа.
* **Форма добавления и редактирования точек**, которая позволяет указать адрес, координаты, описание, категорию и прикрепить фотографию. Для удобства есть автоматический геокодинг: при нажатии «Геокодировать» приложение вызывает API `/api/geocode` и подставляет широту/долготу.
* **Офлайн‑режим**. Благодаря сервис‑воркеру и возможности скачивать тайлы карт и базу геокодирования, приложение может работать без подключения к сети.  
  Потребительские свойства офлайн‑режима соответствуют рекомендациям о Progressive Web Apps: PWA кеширует ресурсы и данные на устройстве и синхронизирует их при восстановлении связи【374043056183291†L279-L307】.
* **Система уведомлений и заявок.** Пользователи Telegram‑бота могут отправлять заявки на добавление точки. Эти заявки отображаются на веб‑странице (иконка колокольчика) и требуют подтверждения или отклонения администратором.
* **Телеграм‑бот**, который позволяет пользователям добавлять точки и получать статус заявки. Для администратора реализовано меню просмотра заявок, одобрения/отклонения, поиска по ID и просмотра сводки.

Проект строится на Flask. Бэкенд разделён на независимые модули (Blueprints), а данные хранятся в базе SQLite. За передачу событий в реальном времени отвечает WebSocket‑сервер, который уведомляет клиента о появлении новых заявок и изменении их статуса.

## Возможности и встроенные компоненты

1. **Карта и маркеры.**  
   На главной странице размещена карта с набором маркеров. Слева находится панель со списком всех точек. Кнопки на верхней панели позволяют: выбирать категорию, фильтровать по типу доступа (локальный/удалённый), добавлять новые точки, импортировать/экспортировать CSV/JSON, **выгружать отчёты в Excel (сводную аналитику и список адресов)**, управлять офлайн‑картами и просматривать уведомления.

2. **Добавление/редактирование точек.**  
   *Окно добавления* открывается при нажатии на фиолетовую кнопку с плюсом. Поля формы:
   - **Адрес** (название).
   - **Широта и долгота** — могут заполняться вручную либо через кнопку «Геокодинг», которая делает запрос к `/api/geocode` и подставляет координаты. Для соединения используется стандартный WebSocket API: при создании объекта `WebSocket` устанавливается соединение【8933817209377†L225-L233】, а дальнейший обмен сообщениями происходит через события `open`, `message` и метод `send()`【8933817209377†L246-L276】.
   - **Описание**, **тип доступа**, **категория**, **ссылка**, **фотография**. Фото сохраняется на сервере в папке `uploads`.
   При редактировании можно заменить фотографию или отметить «Удалить фото». При сохранении сервер проверяет флаг `remove_photo` и удаляет файл.

3. **Фильтрация и поиск.** В верхней строке есть поле поиска (по названию или описанию) и выпадающие списки для фильтрации по категории и типу доступа. В левой панели counters показывают количество точек в каждой категории/статусе.

4. **Система заявок (pending requests).**  
   - **Пользователь через бота** отправляет заявку с адресом/описанием. Заявка сохраняется в таблицу `pending_markers` в базе.
   - **Администратор** видит красный значок колокольчика и может открыть список заявок. При нажатии на заявку открывается форма редактирования, где администратор проверяет данные и нажимает «Сохранить» (одобрить) или «Отклонить».  
   - При одобрении заявка переносится в таблицу `addresses`, а в таблицу `pending_history` добавляется запись со статусом `approved`.  
   - При отклонении заявка удаляется, а в `pending_history` добавляется запись `rejected`.  
   - Все изменения транслируются через WebSocket‑сервер: клиенты получают событие (`pending_created`, `pending_approved`, `pending_rejected`) и обновляют интерфейс.

5. **Офлайн‑карты и геокодинг.**  
   В меню настроек (иконка шестерёнки) можно скачать тайлы OpenStreetMap для выбранного региона и диапазона масштабов, а также выгрузить/загрузить базу адресов для офлайн‑геокодирования. Эти функции выполняют длительные операции и могут быть вынесены в фоновые задачи (например, через Celery).

6. **PWA и сервис‑воркер.**  
   Файл `static/sw.js` регистрирует сервис‑воркер, который кеширует статические файлы, обрабатывает запросы к геокодеру и тайлам и обеспечивает работу приложения без подключения к сети. В сервис‑воркере реализована логика обновления кеша и сброса данных.

   Для важнейших событий (например, новые заявки или сообщения чата) фронтенд использует API уведомлений. При первой загрузке запрашивается разрешение `Notification` — браузер покажет пользователю диалог. Если разрешение получено, при приходе события через WebSocket вызывается `new Notification()`; если вкладка не активна, всплывающие уведомления помогают не пропустить уведомления об активности.

7. **WebSocket‑сервер.**  
   Модуль `app/sockets.py` запускает сервер WebSocket на порту 8765. Клиенты (фронтенд или боты) создают объект `WebSocket` с URL `ws://<host>:8765`. После установления соединения браузер может получать сообщения без опроса сервера. При одобрении/отклонении заявки сервер отправляет событие в формате JSON. На клиенте достаточно добавить слушателя `message` и анализировать поле `event` в пришедшем объекте.

8. **Аналитика.**  
   Бэкенд предоставляет эндпоинт `/api/analytics/summary`, который возвращает сводные показатели:
   * `total` — общее количество объектов,
   * `by_category` — распределение по категориям,
   * `by_status` — распределение по типам доступа,
   * `pending` — количество активных заявок,
   * `approved` и `rejected` — сколько заявок было одобрено и отклонено,
   * `added_last_7d` — сколько объектов создано за последние семь дней.
   Эти данные можно отобразить в отдельной панели администратора или использовать для построения отчётности.

   Помимо API в формате JSON, бэкенд предоставляет эндпоинт `/api/analytics/summary.xlsx`, который
   формирует Excel‑файл с несколькими листами. В этот файл входят сводные показатели за последнюю
   неделю, распределение по категориям и статусам, а также временная динамика. Скачивание отчёта
   реализовано в интерфейсе: в меню «Данные» доступна кнопка «Скачать отчёт Excel».

## Структура проекта и назначение файлов

```
├── run.py                     # Точка запуска приложения. Создаёт Flask‑приложение и запускает WebSocket‑сервер.
├── bot.py                     # Telegram‑бот: диалоги с пользователями и админ‑меню. Использует HTTP‑API и сохраняет сессию.
├── app/
│   ├── __init__.py            # Функция create_app, регистрация blueprints, конфигурация шаблонов и статики.
│   ├── config.py              # Классы конфигурации (DevelopmentConfig, ProductionConfig), переменные окружения.
│   ├── extensions.py          # Инициализация расширений (SQLAlchemy).
│   ├── models.py              # Модели SQLAlchemy: Address, PendingMarker, PendingHistory, Zone.
│   ├── helpers.py             # Вспомогательные функции (авторизация, фильтры, проверка координат).
│   ├── sockets.py             # Запуск WebSocket‑сервера и функции рассылки событий.
│   ├── tasks.py               # Заготовка под фоновые задания (ThreadPoolExecutor).
│   ├── admin/                 # Новые административные маршруты для бота: summary, addresses, applications.
│   │   ├── __init__.py        # Создание Blueprint admin.
│   │   └── routes.py          # Реализация `/admin/summary`, `/admin/addresses` и `/admin/applications`.
│   ├── addresses/             # API адресов (CRUD, импорт/экспорт).
│   │   ├── __init__.py
│   │   └── routes.py          # GET/POST /api/addresses, PUT/DELETE /api/addresses/<id>, batchDelete.
│   ├── pending/               # Работа с очередью заявок: список, approve, reject, clear.
│   │   ├── __init__.py
│   │   └── routes.py
│   ├── requests/              # Маршруты для получения и удаления заявок (использует историю и очередь).
│   │   ├── __init__.py
│   │   └── routes.py
│   ├── bot/                   # Мини‑API для бота (status и cancel заявки).
│   │   ├── __init__.py
│   │   └── routes.py
│   ├── zones/                 # Операции с зонами и GeoJSON‑слоями (пока не используются в интерфейсе).
│   ├── geocode/               # Маршрут для автогеокодирования (`/api/geocode`).
│   ├── offline/               # Скачивание тайлов и базы офлайн‑геокодирования.
│   ├── general/               # Импорт/экспорт CSV/JSON, счётчик заявок.
│   ├── auth/                  # Аутентификация администратора и установка роли.
│   └── storage.py             # Работа с JSON‑файлами (в старой версии — сохранение адресов и заявок).
├── static/
│   ├── css/style.css          # Стили интерфейса: лейаут, цвета, размеры, выравнивание.
│   ├── js/main.js             # Основная логика фронтенда: загрузка данных, рендер списка, работа с картой, модалки, офлайн‑режим, WebSocket.
│   └── sw.js                  # Сервис‑воркер: кеширование ресурсов, обработка fetch, офлайн‑страница.
├── templates/index.html       # Главная HTML‑страница. Содержит разметку для панели, модалок и подключает style.css и main.js.
```

### Краткое описание ключевых файлов

**run.py** — создаёт приложение (`create_app()`), стартует WebSocket‑сервер в отдельном потоке (порт 8765) и запускает встроенный Flask‑сервер. Для предотвращения повторного запуска WebSocket‑сервера используется проверка переменной `WERKZEUG_RUN_MAIN`.

**bot.py** — реализует Telegram‑бота с помощью `python‑telegram‑bot`. Важные части:

* `start` и `help_cmd` — приветственные сообщения и список команд.
* `add_address` и связанные функции — шаги диалога для отправки заявки: собирают адрес, координаты, описание, фото, тип доступа и категорию.
* `admin_entry`, `admin_login_user`, `admin_login_pass` — вход администратора (проверяется на стороне бота, а не сервера).
* `admin_menu_router` — обработка пунктов админ‑меню: просмотр активных, одобренных, отклонённых заявок, поиск по ID, просмотр списка адресов.

**app/models.py** — содержит классы:

* `Address` — таблица адресов. Поля: id, name, lat, lon, notes, status (тип доступа), link, category, photo, timestamps. Метод `to_dict()` сериализует объект.
* `PendingMarker` — очередь заявок. Поля такие же, плюс id пользователя бота и message_id.
* `PendingHistory` — история обработки заявок (pending_id, status, timestamp, address_id).
* `Zone` — модель зон (не используется в этом приложении, но пригодится для будущих слоёв).

**app/addresses/routes.py** — REST‑API для адресов. Поддерживает:

* `GET /api/addresses` — список адресов с фильтрами по названию, категории и статусу.
* `POST /api/addresses` — создание новой точки (multipart — с фото; JSON — без фото).
* `PUT /api/addresses/<id>` — обновление существующей точки. Поддерживает `remove_photo` для удаления изображения.
* `DELETE /api/addresses/<id>` — удаление точки.
* `POST /api/addresses:batchDelete` — массовое удаление.
* `/api/export` и `/api/import` — экспорт/импорт CSV.
* `/api/addresses/export.xlsx` — экспорт списка адресов в Excel. Возвращает
  файл `.xlsx` со всеми полями (`id`, `address`, `lat`, `lon`, `notes`, `status`,
  `category`, `link`, `photo`, timestamps).

**app/pending/routes.py** — работа с очередью заявок:

* `GET /api/pending` — список pending‑заявок (только для администратора).
* `POST /api/pending/<id>/approve` — перенос в адреса (создаёт `Address`, пишет запись истории, отправляет событие `pending_approved`).
* `POST /api/pending/<id>/reject` — отклонение заявки (создаёт запись истории, событие `pending_rejected`).
* `POST /api/pending/clear` — очистка очереди (всем ставится статус `cancelled`).

**app/requests/routes.py** — публичные эндпоинты для проверки количества и получения одной заявки:

* `GET /api/requests/count` — количество ожидающих заявок.
* `GET /api/requests/<id>` — получить одну заявку (используется в интерфейсе для открытия модалки).
* `DELETE /api/requests/<id>` — удалить заявку (используется после одобрения).

**app/admin/routes.py** — новые маршруты для телеграм‑бота:

* `GET /admin/summary` — возвращает статистику: количество активных заявок, одобренных, отклонённых и новых адресов за последние 7 дней, а также общее число адресов.
  * Также доступен эндпоинт `/admin/summary.xlsx`, который формирует Excel‑файл со
    сводной статистикой за последние 7 дней, распределением по категориям и
    статусам и временным графиком. Используется для скачивания отчёта через
    меню «Данные».
* `GET /admin/addresses` — список адресов с пагинацией (параметры `page`, `limit`).
* `GET /admin/applications` — список заявок по статусу (`pending`, `approved`, `rejected`). Для одобренных заявок добавляется информация об адресе.
* `GET /admin/applications/<id>` — подробности о конкретной заявке (pending или из истории).

**app/sockets.py** — сервер WebSocket. Определяет обработчик подключения, хранит список клиентов и предоставляет функции `broadcast_event_sync(event, data)` для рассылки событий. Запускается в отдельном потоке из `run.py`.

**app/offline/routes.py** — загрузка и управление офлайн‑тайлами и базой геокодирования. Реализует:

* `/api/offline/map/stream` — скачивание и архивация тайлов.
* `/api/offline/map/sets` — список доступных наборов тайлов (каталог `data/tiles`).
* `/api/offline/map/activate` — активация набора.
* `/api/offline/geocode/stream` — построение базы офлайн‑геокодов.
* Удаление базы и наборов, просмотр статистики.

**static/js/main.js** — клиентская логика. Главные разделы:

* **Инициализация карты**: создание объекта Leaflet, подгрузка тайлов (онлайн/офлайн), установка обработчиков кликов.
* **Рендер списка адресов**: функция `renderList()` выводит карточки в боковой панели, показывает иконки категории и статуса, выравнивает фото/кнопки.
* **Модалки добавления/редактирования**: `openAdd()`, `saveAdd()`, обработчики ввода, geocode, загрузка фото, удаление фото. Флаг `f-remove-photo` отвечает за удаление картинки.
* **Уведомления**: `fetchPendingRequests()`, `renderNotifList()`, `updateNotifBadge()` периодически обновляют список заявок и счётчик на колокольчике.
* **Офлайн‑режим**: функции для скачивания тайлов и базы геокода, отображение прогресса. Используется `EventSource` для отслеживания прогресса.
* **WebSocket**: подключение к `ws://localhost:8765`, обработка событий и обновление интерфейса в реальном времени.

**static/css/style.css** — стили. Определяет общий макет страницы: левый сайдбар, верхняя панель, модальные окна, таблицы, кнопки. Настраивает цвета (пастельные оттенки), отступы, шрифты иконок. Недавние изменения добавили выравнивание иконок действий по вертикали и корректное положение выпадающих меню.

**templates/index.html** — основная HTML‑страница. Содержит:

* **Верхнюю панель** с логотипом, полем поиска, фильтрами, кнопками (добавить, импорт/экспорт, удалить, шестерёнка, колокольчик, стрелки навигации).  
* **Боковую панель**, где отображается список адресов, счётчики типов, зона drag‑and‑drop для импорта.  
* **Модальные окна**: добавление/редактирование точки, управление офлайн‑картами, просмотр фотографий, модалка выбора роли администратора.  
* Подключает `style.css` и `main.js`.

## Инструкция по развёртыванию и использованию

1. **Установка зависимостей.**  
   Установите Python 3.10+ и используйте виртуальное окружение. Установите библиотеки:  
   `pip install flask flask_sqlalchemy python-telegram-bot websockets requests`.  
   Для фоновых задач можно добавить `celery` и брокер сообщений (Redis/RabbitMQ), если решите расширять проект.

2. **Настройка переменных окружения.**  
   * `MAP_BOT_TOKEN` — токен Telegram‑бота, полученный у @BotFather.  
   * `MAP_API_URL` — URL сервера (по умолчанию `http://localhost:5000`).  
   * (необязательно) `BOT_API_KEY` — секретный ключ для защиты бота.  
   * `ADMIN_USERNAME`, `ADMIN_PASSWORD` (или `ADMIN_PASSWORD_HASH`) — учётные данные администратора.  
   * `DATABASE_URI` — путь к базе (по умолчанию SQLite файл `app.db` в корне).

3. **Запуск сервера.**  
   В каталоге проекта выполните:  
   ```bash
   python run.py
   ```
   Flask‑сервер стартует на `http://0.0.0.0:5000`, а WebSocket‑сервер — на порту 8765. Если порт 8765 занят, измените его в `run.py`. В отладочном режиме Flask дважды запускает код, поэтому `run.py` проверяет переменную `WERKZEUG_RUN_MAIN` и не стартует WebSocket‑сервер повторно.

4. **Запуск Telegram‑бота.**  
   В отдельном терминале запустите:  
   ```bash
   python bot.py
   ```
   Бот будет слушать команды. Обычные пользователи могут отправлять заявки на добавление точки. Администратор должен авторизоваться: команда «/admin» → ввод логина и пароля. После входа доступно меню с просмотрами заявок, их одобрением/отклонением, просмотром списка адресов и сводкой.

5. **Работа с веб‑интерфейсом.**  
   Откройте браузер и перейдите на `http://localhost:5000`. При первом запуске появится модалка выбора роли (администратор или гость).  
   *Гость* может просматривать точки, загружать/импортировать/экспортировать CSV/JSON и скачивать офлайн‑карты.  
   *Администратор* (логин/пароль из переменных окружения) может добавлять/редактировать/удалять точки, подтверждать или отклонять заявки, скачивать офлайн‑базу геокодирования, очищать очередь заявок.

6. **Офлайн‑режим.**  
   *Загрузка тайлов*: в настройках (иконка шестерёнки) выберите диапазон масштабов и нажмите «Скачать». Сервер скачает тайлы OpenStreetMap и сохранит в `data/tiles/<city>`. Активируйте набор, чтобы использовать его вместо онлайн‑тайлов.  
   *База геокодов*: нажмите «Скачать базу адресов». Сервер соберёт список всех адресов с координатами и сохранит `data/offline/geocode.json`. В офлайн‑режиме автогеокодирование будет брать данные из этого файла.  
   В режиме offline сервис‑воркер кэширует страницы и файлы; приложение продолжает работать без сети.

7. **WebSocket‑клиент**.  
   Если вы хотите получать события в режиме реального времени на фронтенде, создайте объект:
   ```js
   const ws = new WebSocket('ws://localhost:8765');
   ws.onmessage = (ev) => {
       const msg = JSON.parse(ev.data);
       if (msg.event === 'pending_created') {
           // обновить счётчик заявок
       }
   };
   ```
   Соединение устанавливается при создании объекта `WebSocket`【8933817209377†L225-L233】; для отправки сообщений используйте `send()`, а для получения — обработчик `message`【8933817209377†L246-L276】.

   Помимо браузерного клиента, проект включает скрипт `ws_cli.py` — простой
   консольный WebSocket‑клиент. Он подключается к серверу (`ws://localhost:8765`), выводит
   все входящие события и предоставляет меню: пункт 1 запускает прослушивание,
   пункт 2 позволяет отправить сообщение пользователю (необходимо указать ID и
   текст), пункт 0 завершает работу. Скрипт удобно использовать администратору
   на сервере без графического интерфейса. Перед запуском установите
   зависимости: `pip install websockets aiohttp`. Запустите командой
   `python ws_cli.py` и следуйте инструкциям в консоли.

8. **Чат между администратором и пользователями.**  
   В интерфейсе карты (справа от значка уведомлений) находится кнопка «Чат» (видна только администраторам). При её нажатии открывается модальное окно: слева отображаются диалоги (список уникальных пользователей), справа — история сообщений и поле ввода.  
   * Как пользоваться: выберите диалог слева, просмотрите историю, введите ответ и нажмите «Отправить». Сообщения от администратора отправляются через API `/api/chat/<user_id>` с заголовком `X-Admin: 1` и сохраняются в базе; бот доставляет их пользователю в Telegram. Новые сообщения от пользователя отображаются в реальном времени благодаря WebSocket‑уведомлениям (`chat_message`). Чтобы просмотреть историю переписки в Telegram, пользователь может отправить команду `/chat`, а чтобы написать админу — `/msg <текст>`. Если администратор предпочитает работать в терминале, он может использовать утилиту `ws_cli.py`, которая позволяет слушать события и отправлять сообщения без браузера.*
   
   Для обработки сообщений на бэкенде используется блюпринт `app/chat`: эндпоинты `/api/chat/conversations`, `/api/chat/<user_id>` и `POST /api/chat/<user_id>`.  
   На стороне клиента вся логика чата находится в функции `bindChatUI()` (файл `static/js/main.js`): она загружает списки диалогов, открывает и закрывает модалку, отправляет сообщения через fetch и подписывается на события WebSocket.

9. **Запуск тестов.**  
   В проект включены модульные тесты, расположенные в каталоге `tests/`. Они проверяют основные функции API (чат, адреса, административные сводки). Чтобы запустить тесты, установите `pytest` (`pip install pytest`) и выполните:  
   ```bash
   pytest
   ```
   При запуске тесты создают временную базу данных в памяти, создают клиента Flask и проверяют корректность работы эндпоинтов (создание, обновление и удаление адресов, отправка сообщений в чат, получение сводки).

## Предложения по глобальным и крутым улучшениям

1. **Многопользовательская система с ролями и авторизацией.**  
   Пока что проект предусматривает только одну пару логин/пароль. Можно добавить модель пользователей и ролей (администратор, модератор, оператор), хранить пароли в базе и использовать Flask‑Login. Это позволит управлять правами доступа тонко и вести журнал действий.

2. **Чат между администратором и пользователями.**  
   Реализуйте отдельный канал WebSocket, где бот будет пересылать вопросы/комментарии от пользователя, а администратор сможет отвечать в панели. Такой чат повысит интерактивность и позволит уточнять данные заявки. WebSocket обеспечивает двустороннюю связь без постоянного опроса сервера【8933817209377†L225-L233】.

3. **Асинхронные фоновые задания.**  
   Интегрируйте Celery с брокером (Redis или RabbitMQ) для выполнения длительных операций (скачивание тайлов, построение базы геокода, экспорт/импорт). Celery позволяет запускать задачи в фоне, устанавливать повторные попытки и ограничивать скорость, что особенно полезно для API‑запросов【418688522630191†L23-L44】.

4. **Компонентный фронтенд на React/Vue.**  
   Разделите интерфейс на компоненты (карта, списки, модалки). Использование современных фреймворков упростит управление состоянием, обеспечит реактивность и позволит масштабировать код. Компонентная архитектура помогает разбивать сложные UI на повторно используемые блоки【748130093796279†L282-L299】.

5. **Использование более мощной СУБД.**  
   SQLite подходит для локальной разработки, но для многопользовательского режима лучше использовать PostgreSQL. Базы данных предназначены для эффективного хранения больших объёмов данных, сложных запросов, транзакций и конкурентного доступа【203832965705165†L40-L70】.

6. **Мобильное приложение или адаптивный дизайн.**  
   Перенесите проект на мобильные платформы через Cordova/Ionic или используйте адаптивные стили, чтобы улучшить работу на телефонах. PWA уже позволяет установить приложение как веб‑приложение, но нативный вид даст больше возможностей (push‑уведомления, офлайн‑данные, GPS).

7. **Расширенные карты и маршруты.**  
   Добавьте маршрутизацию, отображение путей, поиск POI, кластеризацию маркеров. Можно интегрировать внешние сервисы (OSRM, GraphHopper) для прокладки маршрутов.

8. **Расширенная аналитика.**  
   Храните в базе историю действий: кто создавал/редактировал точки, когда и какие данные изменил. Добавьте отчёты (например, сколько точек добавили за период, в каких районах больше всего объектов) и визуализации на карте.

9. **Интеграция с внешними геокодерами.**  
   В дополнение к встроенному офлайн‑геокоду подключите коммерческие API (Google Maps, Яндекс.Карты) для более точного определения координат. Используйте сервисы платных геокодеров с учётом их ограничений по запросам.

10. **Разграничение окружений и CI/CD.**  
   Настройте Docker‑контейнеры для приложения и бота, чтобы упростить развёртывание. Добавьте пайплайн CI/CD (GitHub Actions) для автоматической проверки, тестирования и доставки на сервер.

Проект «Map v12» уже содержит богатую функциональность: он поддерживает офлайн‑режим, интегрирован с Telegram‑ботом, использует WebSocket для уведомлений. Следующие шаги позволят сделать его ещё более масштабируемым, удобным и ориентированным на совместную работу.