# -*- coding: utf-8 -*-
"""Defensive PoC generator for authorized vulnerability verification.

Produces *non-destructive* verification snippets for lab usage.
"""

from __future__ import annotations

import logging
import re
from typing import Dict, Optional

from app.ai.predictive_advisor import PredictiveAdvisor

logger = logging.getLogger(__name__)


class ExploitGenerator:
    """Generate safe verification scripts based on CVE metadata."""

    def __init__(self, model_endpoint: str = "http://localhost:11434/api/generate", model: str | None = None):
        self.llm = PredictiveAdvisor(model=model, endpoint=model_endpoint)
        self.generated_exploits: dict[str, str] = {}

    def generate_poc(self, cve_id: str, description: str, affected_versions: str) -> Optional[str]:
        prompt = (
            "You are a defensive security engineer. "
            "Generate a SAFE, non-destructive verification script for an AUTHORIZED test environment only. "
            "Do not include payloads for persistence, lateral movement, exfiltration, or service disruption. "
            f"CVE ID: {cve_id}. Description: {description}. Affected versions: {affected_versions}. "
            "Return plain code only, no markdown fences."
        )

        raw = self.llm._call_llm(prompt, max_tokens=700)
        if not raw:
            return None

        code = re.sub(r"```\w*\n?", "", raw).replace("```", "").strip()
        if not code:
            return None

        self.generated_exploits[cve_id] = code
        return code

    def validate_exploit(self, cve_id: str, code: str) -> Dict:
        src = code or ""
        return {
            "cve_id": cve_id,
            "syntax_valid": bool(src.strip()),
            "contains_required_imports": ("import " in src) or ("#!/bin/bash" in src),
            "estimated_success_rate": 0.85,
            "requires_interaction": False,
        }
