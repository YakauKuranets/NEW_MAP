# Деплой Map v12 + бот (prod‑контур)

Это краткий конспект, как запускать проект в прод-окружении.

## Быстрый путь (рекомендуется): Docker + Postgres + Nginx + ASGI (HTTP+WS)

В корне проекта есть готовый compose:

```bash
docker compose -f docker-compose.prod.full.yml up -d --build
```

Что поднимается:
- `db` — Postgres
- `web` — ASGI (uvicorn `asgi_realtime:app`, HTTP + WebSocket `/ws` на одном порту)
- `nginx` — reverse‑proxy + раздача `/static` и `/uploads`
- `bot` — Telegram‑бот

Требования:
- заполнить `.env.prod` (секреты, токен бота, пароль админа и т.д.)

Ниже — детали и альтернативы.

## 1. Установка зависимостей

```bash
pip install -r requirements.txt
```

Убедись, что в окружении заданы переменные:
- `APP_ENV=production`
- `FLASK_ENV=production` (опционально)
- `TELEGRAM_BOT_TOKEN=...` и другие секреты (через .env или системные переменные)

## 2. Запуск backend через gunicorn

В корне проекта (там, где лежит `wsgi.py`):

```bash
gunicorn -c deploy/gunicorn.conf.py wsgi:app
```

Это поднимет приложение на порту 8000.

## 3. Запуск через uvicorn/hypercorn (ASGI-вариант, опционально)

Благодаря `asgi.py` можно запускать приложение через ASGI-сервер:

```bash
uvicorn asgi:app --host 0.0.0.0 --port 8000
```

или

```bash
hypercorn asgi:app -b 0.0.0.0:8000
```

## 4. Nginx как фронт

Пример конфига лежит в `deploy/nginx_example.conf`.

Основная идея:
- nginx раздаёт `/static/` и `/uploads/` напрямую с диска;
- все остальные запросы (`/`, `/api/...`, `/admin/...`) проксируются на gunicorn/uvicorn.

## 5. Realtime (WebSocket / SSE) в продакшене

### Вариант А (рекомендуемый): ASGI (HTTP + WS в одном процессе)

Gunicorn (WSGI) **не** обслуживает WebSocket. Поэтому для «боевого» realtime
рекомендуется ASGI запуск:

```bash
uvicorn asgi_realtime:app --host 0.0.0.0 --port 8000
```

WebSocket endpoint: `GET /ws?token=...` (на том же хосте/порту).
Токен выдаётся только администратору через:

- `GET /api/realtime/token`

### Вариант Б (dev/legacy): отдельный WS-порт (8765)

Для режима разработки (`python run.py`) поднимается отдельный WS-сервер
на порту `WS_PORT` (по умолчанию 8765). Подключение также требует токен
из `GET /api/realtime/token`.

> Важно: отдельный WS-сервер **не подходит** для многоворкерного продакшена
> (несколько процессов gunicorn) без внешней шины событий (Redis/RabbitMQ).

## 6. Логи

Управляются через переменные:
- `LOG_LEVEL` (DEBUG/INFO/WARNING/ERROR),
- `LOG_FILE` (если задать путь — логи будут писаться в файл + в stdout).

Формат логов:
```
[2025-11-29 12:00:00,123] INFO in app.routes: Сообщение
```

## 7. Запуск на нескольких машинах (multi-host сценарий)

Типичный боевой сценарий:

1. **Основной сервер backend + веб-интерфейс**

   - Поднимаем `docker-compose.prod.yml` на сервере.
   - На этом же сервере лежит база (`app.db` или внешняя БД) и папка `uploads`.
   - Пользователи и админы заходят в браузере по адресу `http://server:8000`.

2. **Отдельный сервер/машина только для Telegram-бота**

   - Клонируем проект.
   - Заполняем `.env.prod` (включая `MAP_BOT_TOKEN`).
   - В `.env.prod` выставляем `MAP_API_URL=http://server:8000`, где `server` — внешний адрес backend-а.
   - Запускаем:
     ```bash
     docker compose -f docker-compose.bot.yml up -d
     ```
   - Бот будет стучаться в backend по `MAP_API_URL` и не требует общей БД на этой машине.

3. **Несколько компьютеров админов**

   - Админы просто открывают браузер и заходят на адрес backend-а (например, `http://server:8000`).
   - Роли и доступ к зонам управляются внутри самой системы (через UI «Админы» и «Зоны»).

Таким образом, бот живёт в одном месте, backend — в другом (или там же),
а админов/пользователей может быть сколько угодно — они работают через браузер.

## 8. Работа с базой данных и бэкапами

### 8.1. Где лежат базы

По умолчанию проект использует SQLite:

- основная база: `app.db` в корне проекта;
- дополнительная база зон (если используется отдельно): `zones.db`.

Путь к основной базе можно переопределить через переменную окружения
`DATABASE_URI`, например:

```env
# SQLite по умолчанию
DATABASE_URI=sqlite:///app.db

# Пример для Postgres
DATABASE_URI=postgresql+psycopg2://user:password@host:5432/mapv12
```

### 8.2. Быстрый бэкап SQLite

В проект добавлен простой скрипт:

```bash
python tools/backup_sqlite_dbs.py
```

Он создаёт папку `backups/YYYYmmdd_HHMMSS/` и копирует туда `app.db`
и `zones.db` (если файлы существуют).

Рекомендуется:

- запускать скрипт на остановленном приложении (или в моменты низкой нагрузки);
- периодически копировать папку `backups/` на внешний носитель / другое хранилище.

### 8.3. Перенос на Postgres (черновой план)

Если решишь перейти на Postgres в продакшене:

1. Подними Postgres (локально или в Docker).
2. Создай базу данных, например `mapv12`.
3. В `.env.prod` пропиши:

   ```env
   DATABASE_URI=postgresql+psycopg2://user:password@postgres:5432/mapv12
   ```

4. На чистой базе выполни начальную инициализацию таблиц (на данный момент
   проект использует `db.create_all()` при старте; при переходе на
   полноценные миграции можно будет заменить это на `flask db upgrade`).

5. Перенеси данные из `app.db` в Postgres (через любой удобный инструмент:
   `sqlite3` + `COPY`, Alembic-миграции, скрипты на Python и т.д.).

На этом этапе мы лишь готовим конфигурацию и документацию под Postgres,
не включая тяжёлую автоматическую миграцию схемы.

## 9. Логи и health-check

### 9.1. Логирование

Приложение использует стандартный логгер Python и пишет сообщения:

- в stdout (консоль / docker-логи);
- при наличии переменной `LOG_FILE` — дополнительно в файл.

Пример настройки в `.env.prod`:

```env
LOG_LEVEL=INFO
LOG_FILE=/var/log/mapv12/app.log
```

Формат строк лога:

```
[2025-11-29 12:34:56,789] INFO in app.some_module: Сообщение
```

Рекомендуется:

- для разработки использовать `LOG_LEVEL=DEBUG`;
- для продакшена — `LOG_LEVEL=INFO` или `WARNING`;
- следить за размером лог-файла (добавить ротацию средствами ОС или внешнего сервиса).

### 9.2. Эндпоинт /health

Для простого мониторинга добавлен эндпоинт:

```text
GET /health
```

Он возвращает JSON вида:

```json
{
  "status": "ok",
  "db": "ok"
}
```

- `status` — доступность самого приложения;
- `db` — результат лёгкой проверки соединения с базой данных (`SELECT 1`).

Если проверка базы падает, в лог пишется сообщение уровня `ERROR`,
а поле `db` станет `error`.

Эндпоинт полезен для:

- систем мониторинга и оркестраторов (Docker, k8s, внешние health-check сервисы);
- ручной проверки: достаточно открыть `/health` в браузере или сделать `curl`.
